1. Контекст (Context API)
Як застосовано:
Використано Context API для глобального управління станом завдань (todos) в додатку. Це дозволяє зберігати стан завдань в контексті і робити його доступним для всіх компонентів, що потребують доступу до цього стану.
TodoContext використовує createContext для створення контексту, а також надає провайдер, який обгортає весь додаток, забезпечуючи доступ до стану у будь-якому місці.
Користь:
Забезпечує централізоване управління станом додатка без необхідності передавати пропси через кожен компонент.
Полегшує управління станом на глобальному рівні, дозволяючи компонентам взаємодіяти з ним без зайвих переписок.
2. Мемоїзація (Memoization)
Як застосовано:
React.memo використано для мемоїзації компонента TodoItem. Це дозволяє уникнути непотрібних повторних рендерів цього компонента, якщо його пропси не змінилися.
Мемоїзація допомагає оптимізувати рендеринг, особливо коли список завдань стає великим, знижуючи витрати на рендеринг компонентів, які не змінилися.
Користь:
Зменшує кількість непотрібних рендерів, що підвищує продуктивність.
Це особливо важливо для великих списків завдань, де кожен рендер компонента може бути затратним.
3. Організація коду
Як застосовано:
Проект був структурований в окремі папки для різних частин логіки: components, contexts, services тощо. Це дозволяє легко масштабувати проект та підтримувати чистоту і зрозумілість структури.
Компоненти були розбиті на менші та більш керовані одиниці, що дозволяє повторно використовувати код і спрощує тестування.
Користь:
Спрощує масштабування проекту і роботу в команді.
Легко орієнтуватися в проекті, розуміючи де знайти компоненти, логіку та інші важливі частини коду.
4. Лениве завантаження (Lazy Loading)
Як застосовано:
Для оптимізації швидкості завантаження додатка були використані компоненти, які завантажуються лише тоді, коли вони необхідні (наприклад, за допомогою React.lazy()).
Використано Suspense для відображення індикатора завантаження під час завантаження компонентів.
Користь:
Це дозволяє зменшити час початкового завантаження, оскільки компоненти не завантажуються відразу, а тільки за потребою.
Покращує користувацький досвід, оскільки частини інтерфейсу з'являються швидше.
5. Індивідуальні хуки для бізнес-логіки
Як застосовано:
Я по суті створив просто каркас хука, може зарахуєте як 0.5 чисто за знання :)
Це дозволяє робити компоненти чистими і зручними для повторного використання.
Логіка, яка може бути загальною для кількох компонентів, виноситься в окремі хуки для кращого управління.
6. Тестування компонентів (не юзав)
7. Обробка помилок (Error Boundaries)
Як застосовано:
Створено компонент ErrorBoundary, який ловить помилки у дочірніх компонентах і відображає запасний інтерфейс замість того, щоб додаток "пав".
Якщо в компоненті виникає помилка, ErrorBoundary зупиняє її поширення і показує повідомлення про помилку з деталями.
Користь:
Забезпечує надійність додатка, перехоплюючи помилки і не дозволяючи їм призвести до збою додатка.
Покращує користувацький досвід, замість того щоб користувач бачив "чорний екран" або помилку в консоль, вони отримують дружнє повідомлення.
8. Стилізація через Styled Components
Як застосовано:
Для стилізації компонентів використано Styled Components, що дозволяє писати CSS безпосередньо в JavaScript.
Це дозволяє уникнути проблем з глобальними стилями і забезпечує більш чисту та модульну структуру стилів.
Користь:
Запобігає конфліктам стилів і покращує керованість стилями в масштабованих додатках.
Легко адаптувати стилі під різні компоненти, зберігаючи їх модульність і повторне використання.