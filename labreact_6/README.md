# React + Vite



Використані практики компонентно орієнтованого програмування
1. Компонентний підхід: розділення завдань на незалежні компоненти
Практика: Розбиття програми на незалежні компоненти, кожен з яких відповідає за окрему функціональність або частину інтерфейсу.
Як використано:
TodoItem — компонент для відображення одного завдання у списку, з можливістю редагування та видалення.
Login — компонент для авторизації, де користувач може ввести своє ім’я.
TodoApp — головний компонент, що управляє логікою додатку та відображає завдання.
2. Хуки для повторного використання логіки
Практика: Використання хуків для повторного використання логіки в компонентах без створення класів.
Як використано:
useTodoList — користувацький хук для зберігання та управління списком завдань. Цей хук також відповідає за збереження завдань у localStorage для стійкості даних між сесіями.
3. Контрольовані компоненти
Практика: У контрольованих компонентах значення інпутів або інших елементів форми управляються через стан компонента.
Як використано:
У компонентах TodoItem, Login, та TodoApp використовуються контрольовані інпути. Значення полів зберігаються в стані компонента за допомогою useState та змінюються через події, наприклад, onChange.
4. Перевірка типів пропсів за допомогою PropTypes
Практика: Використання PropTypes для валідації типів даних, що передаються в компоненти, що дозволяє уникнути помилок типів під час розробки.
Як використано:
У компоненті TodoItem використано PropTypes для перевірки типів пропсів (task, date, onRemove, onEdit), що гарантує правильні типи даних та зручне налагодження.
5. Збереження стану в localStorage для стійкості даних між сесіями
Практика: Використання localStorage для збереження даних між сесіями, щоб користувачі могли повернутися до своїх завдань навіть після перезавантаження сторінки.
Як використано:
Хук useTodoList зберігає список завдань у localStorage за допомогою localStorage.setItem і читає його при ініціалізації компонента через localStorage.getItem.
6. Адаптивний дизайн
Практика: Адаптивний дизайн забезпечує коректне відображення інтерфейсу на різних пристроях з різними розмірами екранів.
Як використано:
CSS-класи в проекті передбачають адаптивне відображення компонентів на екранах різних розмірів, забезпечуючи коректне масштабування елементів на мобільних пристроях.
7. Розділення логіки та відображення між хуками і компонентами
Практика: Використання хуків для відокремлення бізнес-логіки від UI-компонентів, що покращує читабельність і підтримуваність коду.
Як використано:
Логіка для керування завданнями (додавання, редагування, видалення) винесена в хук useTodoList. Компонент TodoApp відповідає лише за відображення UI і передачу даних до цього хука.
8. Розбиття на маленькі компоненти
Практика: Велика задача або інтерфейс розбивається на менші, більш керовані компоненти, що полегшує підтримку коду.
Як використано:
Всі основні частини додатку, такі як елементи списку завдань, форма входу, логіка додавання/редагування завдань, збережені в окремих компонентах, що робить код більш читабельним і тестованим.






This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh
